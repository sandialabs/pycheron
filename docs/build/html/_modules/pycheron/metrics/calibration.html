<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pycheron.metrics.calibration &#8212; Pycheron 2.1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html"><span><img src="../../../_static/horse-128.png"></span>
          Pycheron</a>
        <span class="navbar-text navbar-version pull-left"><b>2.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../install.html">Install</a></li>
                <li><a href="../../../pycheron.html">Documentation</a></li>
                <li><a href="https://gitlab.sandia.gov/lynm/pycheron">Gitlab</a></li>
                <li><a href="tutorials">Tutorials</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Documentation <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for pycheron.metrics.calibration</h1><div class="highlight"><pre>
<span></span>
<span class="c1">#TODO this function needs a major rewrite, it&#39;s too much inside one function and could be better modularized</span>
<span class="c1">#TODO need to look into threshold parametrizations</span>
<span class="c1">#TODO need masking for cals</span>


<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">dir_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dir_path</span> <span class="o">+</span> <span class="s1">&#39;/..&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">obspy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pycheron.db.sqllite_db</span> <span class="k">import</span> <span class="n">Database</span>
<span class="kn">import</span> <span class="nn">pycheron.pywavcorr</span> <span class="k">as</span> <span class="nn">pwc</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">signal</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;LogComressor&quot;</span><span class="p">,</span> <span class="s2">&quot;leaky_integrator&quot;</span><span class="p">,</span> <span class="s2">&quot;LTIFilter&quot;</span><span class="p">,</span> <span class="s2">&quot;FrameContainer&quot;</span><span class="p">,</span> <span class="s2">&quot;MLApplier&quot;</span><span class="p">,</span>
           <span class="s2">&quot;CalibrationHelper&quot;</span><span class="p">,</span> <span class="s2">&quot;unscreened_calibration&quot;</span><span class="p">,</span> <span class="s2">&quot;calibration&quot;</span><span class="p">,</span> <span class="s2">&quot;calibrationMetric&quot;</span><span class="p">]</span>

<span class="n">__calibration_demo__</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="LogComressor"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.LogComressor">[docs]</a><span class="k">class</span> <span class="nc">LogComressor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to log compress data, then replace all instances of -INF with minimum of</span>
<span class="sd">    that row, and replace INF with maximum of that row. Class used to create compressor.pkl&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_compress</span><span class="p">(</span><span class="n">features</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">features</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">features</span>

<div class="viewcode-block" id="LogComressor.fit"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.LogComressor.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">):</span>
        <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compress</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mins_and_maxs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">features</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mins_and_maxs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">temp</span><span class="p">)])</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="LogComressor.transform"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.LogComressor.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_mins_and_maxs&#39;</span><span class="p">),</span> <span class="s1">&#39;LogCompressor object has &#39;</span> \
                                                <span class="s1">&#39;not been fit yet!&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mins_and_maxs</span><span class="p">)</span> <span class="o">==</span> <span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> \
            <span class="s1">&#39;invalid input sizes&#39;</span>

        <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compress</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">features</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">features</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mins_and_maxs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">features</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">features</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mins_and_maxs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">features</span></div></div>


<div class="viewcode-block" id="leaky_integrator"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.leaky_integrator">[docs]</a><span class="k">def</span> <span class="nf">leaky_integrator</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">dur</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Single pole filter (leaky integrator I think)</span>
<span class="sd">    The impulse response is a decaying exponential.  The longer the &lt;dur&gt;</span>
<span class="sd">    is, the longer this exponential will take to decay.</span>
<span class="sd">    :param fs: sampling frequency (Hz)</span>
<span class="sd">    :param dur: time at which impulse response has decayed to below 90%</span>
<span class="sd">                longer &lt;dur&gt; implies longer startup and more aggressive LPF</span>
<span class="sd">    :return: filter coefficients</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span> <span class="o">/</span> <span class="n">fs</span> <span class="o">*</span> <span class="o">.</span><span class="mi">01150</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">dur</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="n">A</span></div>


<div class="viewcode-block" id="LTIFilter"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.LTIFilter">[docs]</a><span class="k">class</span> <span class="nc">LTIFilter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper class that manages storing and updating initial/final conditions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zi</span> <span class="o">=</span> <span class="n">zi</span>

<div class="viewcode-block" id="LTIFilter.has_initial_condition"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.LTIFilter.has_initial_condition">[docs]</a>    <span class="k">def</span> <span class="nf">has_initial_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LTIFilter.filter"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.LTIFilter.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">zf</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">zi</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">zi</span> <span class="o">=</span> <span class="n">zf</span>

        <span class="k">return</span> <span class="n">y</span></div></div>


<div class="viewcode-block" id="FrameContainer"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.FrameContainer">[docs]</a><span class="k">class</span> <span class="nc">FrameContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_size</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_size</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

<div class="viewcode-block" id="FrameContainer.clear"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.FrameContainer.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="FrameContainer.size"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.FrameContainer.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="FrameContainer.empty"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.FrameContainer.empty">[docs]</a>    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="FrameContainer.full"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.FrameContainer.full">[docs]</a>    <span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_size</span></div>

<div class="viewcode-block" id="FrameContainer.add"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.FrameContainer.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span><span class="p">():</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span></div>

<div class="viewcode-block" id="FrameContainer.get"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.FrameContainer.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s1">&#39;container is empty&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">index</span><span class="p">,</span> <span class="s1">&#39;index is higher than container size&#39;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">index</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="MLApplier"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.MLApplier">[docs]</a><span class="k">class</span> <span class="nc">MLApplier</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class screens detections using a trained machine learning</span>
<span class="sd">    classifier and some preprocessing steps that are all loaded from pickle</span>
<span class="sd">    files.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadpath</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_ml_objects</span><span class="p">(</span><span class="n">loadpath</span><span class="p">)</span>

<div class="viewcode-block" id="MLApplier.load_ml_objects"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.MLApplier.load_ml_objects">[docs]</a>    <span class="k">def</span> <span class="nf">load_ml_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirpath</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">dirpath</span> <span class="o">+</span> <span class="s1">&#39;compressor.pkl&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
            <span class="n">compressor</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="n">dirpath</span> <span class="o">+</span> <span class="s1">&#39;imputer.pkl&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
            <span class="n">imputer</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="n">dirpath</span> <span class="o">+</span> <span class="s1">&#39;scaler.pkl&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="n">dirpath</span> <span class="o">+</span> <span class="s1">&#39;classifier.pkl&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
            <span class="n">classifier</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compressor</span> <span class="o">=</span> <span class="n">compressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imputer</span> <span class="o">=</span> <span class="n">imputer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span> <span class="o">=</span> <span class="n">scaler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">classifier</span></div>

<div class="viewcode-block" id="MLApplier.iscal"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.MLApplier.iscal">[docs]</a>    <span class="k">def</span> <span class="nf">iscal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if it is a calibration&quot;&quot;&quot;</span>

        <span class="c1"># get data</span>
        <span class="n">issue_start_time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">detection</span><span class="p">[</span><span class="s1">&#39;cal_start_time&#39;</span><span class="p">])</span>
        <span class="n">issue_end_time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">detection</span><span class="p">[</span><span class="s1">&#39;cal_end_time&#39;</span><span class="p">])</span>
        <span class="n">original_start_time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">detection</span><span class="p">[</span><span class="s1">&#39;initial_cal_start_time&#39;</span><span class="p">])</span>
        <span class="n">original_end_time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">detection</span><span class="p">[</span><span class="s1">&#39;initial_cal_end_time&#39;</span><span class="p">])</span>
        <span class="n">cal_duration</span> <span class="o">=</span> <span class="n">issue_end_time</span> <span class="o">-</span> <span class="n">issue_start_time</span>
        <span class="n">Ts_minus_Tos</span> <span class="o">=</span> <span class="n">issue_start_time</span> <span class="o">-</span> <span class="n">original_start_time</span>
        <span class="n">Toe_minus_Te</span> <span class="o">=</span> <span class="o">-</span> <span class="n">issue_end_time</span> <span class="o">+</span> <span class="n">original_end_time</span>

        <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">cal_duration</span><span class="p">,</span> <span class="n">Ts_minus_Tos</span><span class="p">,</span> <span class="n">Toe_minus_Te</span><span class="p">]</span>
        <span class="n">features</span> <span class="o">+=</span> <span class="p">[</span><span class="n">detection</span><span class="p">[</span><span class="s1">&#39;max_ySmooth&#39;</span><span class="p">],</span>
                     <span class="n">detection</span><span class="p">[</span><span class="s1">&#39;max_stalta&#39;</span><span class="p">],</span>
                     <span class="n">detection</span><span class="p">[</span><span class="s1">&#39;env_mean&#39;</span><span class="p">],</span>
                     <span class="n">detection</span><span class="p">[</span><span class="s1">&#39;env_median&#39;</span><span class="p">],</span>
                     <span class="n">detection</span><span class="p">[</span><span class="s1">&#39;env_var&#39;</span><span class="p">],</span>
                     <span class="n">detection</span><span class="p">[</span><span class="s1">&#39;stft_var&#39;</span><span class="p">]]</span>

        <span class="c1"># transform features</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">features</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressor</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
        <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imputer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
        <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

        <span class="c1"># apply classifier</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">prediction</span> <span class="o">==</span> <span class="mi">1</span></div></div>


<div class="viewcode-block" id="CalibrationHelper"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.CalibrationHelper">[docs]</a><span class="k">class</span> <span class="nc">CalibrationHelper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is a helper to the calibration function.  A single</span>
<span class="sd">    private object is instantiated and used by the function for</span>
<span class="sd">    configuration of parameters and storing data from previously viewed</span>
<span class="sd">    traces, in the case that data is being streamed to the function.</span>

<span class="sd">    The function can be dramatically changed by adjusting parameter values</span>
<span class="sd">    in _config().</span>

<span class="sd">    update_state() handles all stored data and filters based on whether the</span>
<span class="sd">    new trace is a contiguous block after the previously viewed trace.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">do_plot</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fc_snclq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc_starttime</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc_endtime</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">()</span>

<div class="viewcode-block" id="CalibrationHelper.update_state"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.CalibrationHelper.update_state">[docs]</a>    <span class="k">def</span> <span class="nf">update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update anything that changed, such as sampling rate</span>
<span class="sd">        and check whether caches need to be cleared, which occurs when</span>
<span class="sd">        non-continuous traces are provided, i.e. different SNCLQ or</span>
<span class="sd">        discontiguous start/end times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">!=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_filters</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bufferdur</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>

        <span class="n">snclq</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc_snclq</span> <span class="o">!=</span> <span class="n">snclq</span>
                <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc_endtime</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_time_eps</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc_snclq</span> <span class="o">=</span> <span class="n">snclq</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc_starttime</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc_endtime</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_filters</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_frame_containers</span><span class="p">()</span>
            
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bufferdur</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minDetectionDuration</span><span class="p">,</span> \
                <span class="s1">&#39;each frame must last longer than the minimum detection duration&#39;</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure parameter settings for the calibration function.  The</span>
<span class="sd">        current configuration is tuned pretty well for IMS stations.  It is</span>
<span class="sd">        unknown if this performs well on other stations, however,</span>
<span class="sd">        the objective is to measure relative levels, i.e. how large is this</span>
<span class="sd">        value compared to typical values on this channel? Thus, it should</span>
<span class="sd">        adapt to any network.</span>

<span class="sd">        Any &quot;dur...&quot; for a filter is specifying the &lt;dur&gt; to be used in the</span>
<span class="sd">        design of a leaky_integrator filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO (maybe) sweep for optimal ST, MT, LT and threshold</span>
        <span class="c1"># make it something that can be automatically done in the future</span>

        <span class="c1"># duration for high-pass filter of x</span>
        <span class="c1"># (high-pass is x - xLowPass)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">durXHP</span> <span class="o">=</span> <span class="mi">3600</span> <span class="o">*</span> <span class="mi">24</span>
        <span class="c1"># self.durXHP = 60</span>

        <span class="c1"># short-time, long-time and threshold for LTA/STA ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">durShort</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="c1"># self.durShort = 3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">durLong</span> <span class="o">=</span> <span class="mi">60</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># TODO: Tested some other thresholds, like 2.5, to try to catch other calibrations</span>
        <span class="c1"># TODO: need to play with this more</span>

        <span class="c1"># filtering LTA/STA to smooth spikes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">durYSmooth</span> <span class="o">=</span> <span class="mi">15</span>

        <span class="c1"># window duration for envelope filter (hanning window)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">durEnvFilter</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="c1"># minimum gap between detection start/end times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minDetectionDuration</span> <span class="o">=</span> <span class="mi">20</span>

        <span class="c1"># this filter estimates typical envelope energy.</span>
        <span class="c1"># it is only updated per frame if no detections are found</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">durAbsXLP</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">6</span>
        <span class="c1"># lag for estimate of typical envelope energy such that if a</span>
        <span class="c1"># cal pulse occurs it does not unnaturally raise the denominator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">envelope_ratio_denominator_lag</span> <span class="o">=</span> <span class="mi">3600</span> <span class="o">*</span> <span class="mi">24</span>

        <span class="c1"># STA and LTA times to recalibrate the start time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recal_tLong</span> <span class="o">=</span> <span class="mi">30</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recal_tShort</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span>

        <span class="c1"># frame container durations (max amount of previous information stored)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc_dur</span> <span class="o">=</span> <span class="mi">3600</span> <span class="o">*</span> <span class="mi">24</span>
        <span class="c1"># maximum gap between frames to not clear cache (seconds)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc_time_eps</span> <span class="o">=</span> <span class="mi">60</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">minDetectionDuration</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">durEnvFilter</span><span class="p">,</span> \
            <span class="s1">&#39;gap between start and end times for a detection must be &#39;</span> \
            <span class="s1">&#39;greater than the envelope filter start-up&#39;</span>

        <span class="c1"># path to pickled machine learning objects used to screen initial</span>
        <span class="c1"># calibration detections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ml_loadpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/calibration_ml_objects/&#39;</span>

    <span class="k">def</span> <span class="nf">_update_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># filter DC from signal</span>
        <span class="n">B</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">leaky_integrator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">durXHP</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;DC_remover&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LTIFilter</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>

        <span class="c1"># compute STA, LTA on |x[n]|</span>
        <span class="n">B</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">leaky_integrator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">durShort</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;sta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LTIFilter</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>

        <span class="n">B</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">leaky_integrator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">durLong</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;lta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LTIFilter</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>

        <span class="c1"># smooth LTA/STA</span>
        <span class="n">B</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">leaky_integrator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">durYSmooth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;ltasta_smoother&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LTIFilter</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>

        <span class="c1"># computing signal envelope</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">durEnvFilter</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">))</span>
        <span class="n">B</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;envelope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LTIFilter</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">)</span>

        <span class="c1"># this filter estimates typical envelope level.</span>
        <span class="c1"># it is only updated per frame if no detections are found</span>
        <span class="n">B</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">leaky_integrator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">durAbsXLP</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;absxLP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LTIFilter</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_frame_containers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bufferdur&#39;</span><span class="p">),</span> <span class="s1">&#39;bufferdur hasn</span><span class="se">\&#39;</span><span class="s1">t been set yet!&#39;</span>

        <span class="c1"># stores previous frames of x</span>
        <span class="n">max_num_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_dur</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bufferdur</span>
        <span class="n">max_num_frames</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">max_num_frames</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">FCx</span> <span class="o">=</span> <span class="n">FrameContainer</span><span class="p">(</span><span class="n">max_num_frames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FCy</span> <span class="o">=</span> <span class="n">FrameContainer</span><span class="p">(</span><span class="n">max_num_frames</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">FCsta</span> <span class="o">=</span> <span class="n">FrameContainer</span><span class="p">(</span><span class="n">max_num_frames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FClta</span> <span class="o">=</span> <span class="n">FrameContainer</span><span class="p">(</span><span class="n">max_num_frames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FCySmooth</span> <span class="o">=</span> <span class="n">FrameContainer</span><span class="p">(</span><span class="n">max_num_frames</span><span class="p">)</span>

        <span class="n">max_num_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">envelope_ratio_denominator_lag</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bufferdur</span>
        <span class="n">max_num_frames</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">max_num_frames</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FCzi</span> <span class="o">=</span> <span class="n">FrameContainer</span><span class="p">(</span><span class="n">max_num_frames</span><span class="p">)</span>

<div class="viewcode-block" id="CalibrationHelper.iscal"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.CalibrationHelper.iscal">[docs]</a>    <span class="k">def</span> <span class="nf">iscal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detection</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ml_applier&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ml_applier</span> <span class="o">=</span> <span class="n">MLApplier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml_loadpath</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ml_applier</span><span class="o">.</span><span class="n">iscal</span><span class="p">(</span><span class="n">detection</span><span class="p">)</span></div></div>


<span class="n">_chelper</span> <span class="o">=</span> <span class="n">CalibrationHelper</span><span class="p">()</span>


<div class="viewcode-block" id="unscreened_calibration"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.unscreened_calibration">[docs]</a><span class="k">def</span> <span class="nf">unscreened_calibration</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">metric_store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function automatically detects calibrations in seismic data.  It was</span>
<span class="sd">    originally tuned to identify &quot;stationary rect calibrations&quot; which means</span>
<span class="sd">    high amplitude calibrations that have roughly a rect (square) envelope and</span>
<span class="sd">    appear stationary within the envelope. Upon running the code on data it</span>
<span class="sd">    was found that many other types of calibrations were also being identified.</span>
<span class="sd">    Thus, this algorithm is primarily tuned to a specific type of calibration</span>
<span class="sd">    but still has use in other cases.</span>

<span class="sd">    The general algorithm is as follows:</span>
<span class="sd">        1) an LTA/STA is run looking for triggers above threshold.  This is</span>
<span class="sd">        due to the fact that seismic arrivals can have abrupt transient</span>
<span class="sd">        ONSETs however the...OFFSET? is not as abrupt, whereas these</span>
<span class="sd">        calibrations to have an abrupt drop in energy.</span>

<span class="sd">        2) For these candidate triggers, start time is found by:</span>
<span class="sd">            a) computing an envelope for the data</span>
<span class="sd">            b) normalizing the envelope by the typical channel energy,</span>
<span class="sd">            such that anything above 1 is high</span>
<span class="sd">            c) searching BACKWARDS in time until something below 1 is</span>
<span class="sd">            identified, i.e. the channel has returned to normal energy levels</span>

<span class="sd">        3) The start and end times are refined.  The start time is refined</span>
<span class="sd">        by using an STA/LTA trigger, the end time is shifted to the time</span>
<span class="sd">        where LTA becomes &gt; STA.  Both of these refined times will shorten</span>
<span class="sd">        the overall duration of the calibration</span>

<span class="sd">        4) These calibrations (could be 0 or more) can very often be false</span>
<span class="sd">        alarms. A second step is then implemented to screen the candidate</span>
<span class="sd">        calibrations.  The current implementation is somewhat complex,</span>
<span class="sd">        using a machine learning classifier and a collection of statistics,</span>
<span class="sd">        however, in the future it is possible to implement a rather simple</span>
<span class="sd">        set of conditions to keep a calibration.  For example:</span>
<span class="sd">            if duration &lt; 5 seconds or energy &lt; 3 X typical_energy_level:</span>
<span class="sd">                discard calibration</span>

<span class="sd">        5) The previous step is the final step to return a result, however</span>
<span class="sd">        some values are cached in order to process streams of data more</span>
<span class="sd">        accurately.  Details on this will be described shortly.</span>

<span class="sd">    Despite being a function, a private calibration helper object exists in</span>
<span class="sd">    volatile memory in order to assist calibration() as if it were an object.</span>
<span class="sd">    This object contains many parameter settings as well as caching data.</span>
<span class="sd">    One of the common reasons for caching data is that this algorithm</span>
<span class="sd">    identifies the END of a calibration, however, some calibrations can last</span>
<span class="sd">    very long.  If the calibration started before the provided trace&#39;s start</span>
<span class="sd">    time, more data is required to identify an accurate start time.</span>

<span class="sd">    ---------------------------------------------------------------------------</span>
<span class="sd">    About caching as using this function on sequential blocks of data.</span>

<span class="sd">    This function works best when applied to continuous streams of data.</span>
<span class="sd">    For example:</span>

<span class="sd">     snclq = &lt;a unique and consistent snclq&gt;</span>
<span class="sd">     for start_hour in range(0, 48, 1):</span>
<span class="sd">        end_hour = start_hour + 1</span>
<span class="sd">        trace = &lt;a trace that starts at start_hour and ends at end_hour&gt;</span>
<span class="sd">        results = calibration(trace)</span>

<span class="sd">     It is not so much important that the durations are constant, but that</span>
<span class="sd">     the end time of the previous frame is the same as the start tiem of the</span>
<span class="sd">     current frame.  If this is true, all cached data will be stored,</span>
<span class="sd">     not cleared, and can be used to assist in the calibration detection. This</span>
<span class="sd">     function was initially written to be processed on weeks to years at a</span>
<span class="sd">     time, however I would say at a maximum (so long as the current parameter</span>
<span class="sd">     settings are preserved) it takes a day to get all of the caches and data</span>
<span class="sd">     to steady-state.  Thus, if you want accurate results for Monday,</span>
<span class="sd">     run Sunday and Monday sequentially.</span>

<span class="sd">     The caches are FrameContainer objects, that much like a Queue that</span>
<span class="sd">     stores a fixed number of previous frames.  The important frame</span>
<span class="sd">     containers are:</span>
<span class="sd">        FCzi - this is the initial/final state of a filter used to estimate</span>
<span class="sd">        the typical (average) value of the signal envelope. This way the</span>
<span class="sd">        envelope can be normalized by this value and we can look for any</span>
<span class="sd">        times that the normalized envelope is significantly above one.</span>

<span class="sd">        FCx - stored time-series data (with DC removed). This is important</span>
<span class="sd">        for stepping back in time to find the start of a calibration,</span>
<span class="sd">        (in the event that the calibration spans multiple traces)</span>

<span class="sd">        FCy and FCySmooth are used similar to FCx, but could be recomputed</span>
<span class="sd">        from FCx if storage is more important than compute time.</span>

<span class="sd">        FCsta and FClta are not used in any way for processing, however they</span>
<span class="sd">        are useful for plotitng and visualizations.  Similar to FCy and</span>
<span class="sd">        FCySmooth, they could be computed from FCx if need be.</span>

<span class="sd">    So if the caches are cleared, which occurs when discontiguous traces are</span>
<span class="sd">    passed to calibration(), different snclq&#39;s are passed in or separate</span>
<span class="sd">    processes are instantiated, the caches will be cleared.  This means</span>
<span class="sd">    envelope normalization may not be accurate and if the calibration spans</span>
<span class="sd">    to earlier than the current trace it may not be identified. Also,</span>
<span class="sd">    filter initializations won&#39;t be accurate.  The filters to look out for</span>
<span class="sd">    are ones with long durations, such as the DC removal filter.  Short</span>
<span class="sd">    duration filters will adapt to the different initial conditions very</span>
<span class="sd">    quickly.</span>

<span class="sd">    ---------------------------------------------------------------------------</span>

<span class="sd">    :param trace:   an obspy trace object</span>
<span class="sd">    :param metric_store:    optional MetricStore</span>
<span class="sd">        (this is currently not used)</span>
<span class="sd">    :param debug:   flag, things are plotted and printed if set to True</span>
<span class="sd">    :param params: currently not used</span>
<span class="sd">    :return:  Some form of list of identified calibrations where each</span>
<span class="sd">    calibration is guaranteed to have:</span>
<span class="sd">        SNCLQ, start_time, end_time</span>
<span class="sd">    and may have additional statistics.  These details are specified in near</span>
<span class="sd">    the return statement.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_time_series_set</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acquire all time-series&#39; that will be used in detecting</span>
<span class="sd">        calibrations, primarily for initial trigger of candidate calibration</span>
<span class="sd">        detection.</span>
<span class="sd">        :param x: input time-series</span>
<span class="sd">        :return:</span>
<span class="sd">            x       - the input with DC removed (via LTI filter)</span>
<span class="sd">            xLP     - the input LP filtered to only contain DC</span>
<span class="sd">            sta     - short-term average</span>
<span class="sd">            lta     - long-term average</span>
<span class="sd">            y       - LTA / STA (that&#39;s right, the reciprocal of what you&#39;re</span>
<span class="sd">                       used to)</span>
<span class="sd">            ySmooth - filtered / smoothed version of &#39;y&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot;remove DC&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;DC_remover&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">has_initial_condition</span><span class="p">():</span>
            <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;DC_remover&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">zi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

        <span class="n">xLP</span> <span class="o">=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;DC_remover&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">xLP</span>

        <span class="sd">&quot;&quot;&quot;compute LTA/STA&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;sta&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">has_initial_condition</span><span class="p">():</span>
            <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;sta&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">zi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
            <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;lta&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">zi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>

        <span class="n">sta</span> <span class="o">=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;sta&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">lta</span> <span class="o">=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;lta&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">lta</span> <span class="o">/</span> <span class="n">sta</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot;Smooth &#39;y&#39; (maybe after detection check)&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;ltasta_smoother&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">has_initial_condition</span><span class="p">():</span>
            <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;ltasta_smoother&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">zi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>

        <span class="n">ySmooth</span> <span class="o">=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;ltasta_smoother&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xLP</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">lta</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ySmooth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_candidate_indices</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;indices where LTA/STA triggers above threshold&quot;&quot;&quot;</span>

        <span class="c1"># find values above threshold</span>
        <span class="n">candidate_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                             <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span><span class="p">]</span>

        <span class="c1"># remove trailing consecutive indices</span>
        <span class="n">candidate_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">candidate_indices</span>
                             <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">candidate_indices</span><span class="p">]</span>

        <span class="c1"># remove 0 from indices if this is a continuation of a detection</span>
        <span class="c1"># from the previous frame or there is no previous frame</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">candidate_indices</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCySmooth</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span>
                     <span class="ow">or</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCySmooth</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span><span class="p">)):</span>
            <span class="k">del</span> <span class="n">candidate_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">candidate_indices</span>

    <span class="k">def</span> <span class="nf">initialize_detections</span><span class="p">(</span><span class="n">candidate_indices</span><span class="p">,</span> <span class="n">ySmooth</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Detections are managed as dictionaries where keys are added and</span>
<span class="sd">        deleted as necessary.  This function simply initializes this list</span>
<span class="sd">        of dictionaries.&quot;&quot;&quot;</span>
        <span class="n">cal_detections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">candidate_indices</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">ySmooth</span><span class="p">[</span><span class="n">idx</span><span class="p">::]</span>

            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
                <span class="c1"># ySmooth returns below threshold, find the snippet that is</span>
                <span class="c1"># above threshold (temp)</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">temp</span> <span class="o">&lt;</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">idx2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span>

            <span class="c1"># the initial end_time is at the trigger index</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> <span class="n">idx</span> <span class="o">/</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span>

            <span class="n">cur_detection</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;idx&#39;</span><span class="p">:</span> <span class="n">idx</span><span class="p">,</span>
                             <span class="s1">&#39;initial_cal_end_time&#39;</span><span class="p">:</span> <span class="n">end_time</span><span class="p">,</span>
                             <span class="s1">&#39;max_ySmooth&#39;</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">temp</span><span class="p">)}</span>
            <span class="n">cal_detections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_detection</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cal_detections</span>

    <span class="k">def</span> <span class="nf">clear_failed_detections</span><span class="p">(</span><span class="n">cal_detections</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cal_detections</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;initial_cal_start_time&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cal_detections</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">cal_detections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># flag that notifies the function to plot the data if debugging and a</span>
    <span class="c1"># candidate calibration fails some condition. Will never plot if &#39;debug&#39;</span>
    <span class="c1"># is False</span>
    <span class="n">_chelper</span><span class="o">.</span><span class="n">do_plot</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># update CalibrationHelper with new trace&#39;s information</span>
    <span class="n">_chelper</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;generate all of the required time-series&#39; &quot;&quot;&quot;</span>

    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xLP</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">lta</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ySmooth</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_time_series_set</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;check for detections&quot;&quot;&quot;</span>

    <span class="n">candidate_indices</span> <span class="o">=</span> <span class="n">get_candidate_indices</span><span class="p">(</span><span class="n">ySmooth</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">__calibration_demo__</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="s1">&#39;211&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data with DC removed&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">xLP</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;DC that was removed&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">lta</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Long Term Average (LTA)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Short Term Average (STA)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t (seconds)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;seismic data&#39;</span><span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="s1">&#39;212&#39;</span><span class="p">);</span>
        <span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;LTA / STA&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ySmooth</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;smoothed LTA / STA&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
                 <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;threshold trigger level&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">candidate_indices</span><span class="p">],</span> <span class="n">ySmooth</span><span class="p">[</span><span class="n">candidate_indices</span><span class="p">],</span>
                 <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;detection triggers&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t (seconds)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;LTA/STA data&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="sd">&quot;&quot;&quot;initialize the current detections&quot;&quot;&quot;</span>

    <span class="n">cal_detections</span> <span class="o">=</span> <span class="n">initialize_detections</span><span class="p">(</span><span class="n">candidate_indices</span><span class="p">,</span> <span class="n">ySmooth</span><span class="p">,</span> <span class="n">trace</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;Get start/end times for candidate detections&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="c1"># only do this once!</span>
        <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))])</span>

    <span class="k">for</span> <span class="n">cur_detection</span> <span class="ow">in</span> <span class="n">cal_detections</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span>

        <span class="sd">&quot;&quot;&quot;acquire accurate end time,</span>
<span class="sd">        (which is the transition where the LTA becomes &gt; STA)&quot;&quot;&quot;</span>

        <span class="n">y_reverse</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># add previous frames until something under 1 is found</span>
        <span class="k">for</span> <span class="n">previous_y</span> <span class="ow">in</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCy</span><span class="p">:</span>
            <span class="n">y_reverse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">y_reverse</span><span class="p">,</span> <span class="n">previous_y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_reverse</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">end_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">y_reverse</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">end_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># there is no transition point in all the data, void this</span>
            <span class="c1"># candidate index</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;FAIL 1: finding accurate end_time&#39;</span><span class="p">)</span>
                <span class="n">_chelper</span><span class="o">.</span><span class="n">do_plot</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">continue</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">end_idx</span>

        <span class="n">issue_end_time</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> <span class="n">end_idx</span> <span class="o">/</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span>
        <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;end_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">issue_end_time</span>

        <span class="sd">&quot;&quot;&quot;find a start time&quot;&quot;&quot;</span>

        <span class="n">absx_reverse</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">end_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># when looking for start, ignore indices below this</span>
        <span class="n">search_start_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_chelper</span><span class="o">.</span><span class="n">minDetectionDuration</span> <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">FCx_start_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># add frames until more than min detection duration is acquired</span>
        <span class="k">for</span> <span class="n">x_curframe</span> <span class="ow">in</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="p">:</span>
            <span class="n">FCx_start_idx</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">absx_rev_curframe</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x_curframe</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># first, append frames until min search length is acquired</span>
            <span class="n">absx_reverse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">absx_reverse</span><span class="p">,</span> <span class="n">absx_rev_curframe</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">absx_reverse</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">search_start_idx</span>
                                    <span class="o">+</span> <span class="p">(</span><span class="n">end_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">end_idx</span><span class="p">)):</span>
                <span class="k">break</span>

        <span class="n">absx_reverse</span> <span class="o">=</span> <span class="n">absx_reverse</span><span class="p">[(</span><span class="n">end_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">end_idx</span><span class="p">)::]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">absx_reverse</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">search_start_idx</span><span class="p">:</span>
            <span class="c1"># not enough data to find a start, reject this candidate detection</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;FAIL 2: not enough data for start_time&#39;</span><span class="p">)</span>
                <span class="n">_chelper</span><span class="o">.</span><span class="n">do_plot</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">continue</span>

        <span class="c1"># compute the envelope</span>
        <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;envelope&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">zi</span> \
            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;envelope&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;envelope&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">absx_reverse</span><span class="p">)</span>

        <span class="c1"># normalize as a ratio to typical envelope level</span>
        <span class="n">env</span> <span class="o">/=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># add previous frames until something under 1 is found</span>
        <span class="k">for</span> <span class="n">cur_idx</span><span class="p">,</span> <span class="n">x_curframe</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cur_idx</span> <span class="o">&lt;</span> <span class="n">FCx_start_idx</span><span class="p">:</span>
                <span class="c1"># skip the frames that have already been added</span>
                <span class="k">continue</span>

            <span class="n">absx_rev_curframe</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x_curframe</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># compute the envelope</span>
            <span class="n">env_curframe</span> \
                <span class="o">=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;envelope&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">absx_rev_curframe</span><span class="p">)</span>

            <span class="c1"># normalize as a ratio to typical envelope level</span>
            <span class="n">env_curframe</span> <span class="o">/=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">env</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">env</span><span class="p">,</span> <span class="n">env_curframe</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">env</span><span class="p">[</span><span class="n">search_start_idx</span><span class="p">::])</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">env</span><span class="p">[</span><span class="n">search_start_idx</span><span class="p">::]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">])</span> \
                    <span class="o">+</span> <span class="n">search_start_idx</span>

        <span class="k">if</span> <span class="n">start_idx</span> <span class="o">==</span> <span class="n">search_start_idx</span><span class="p">:</span>
            <span class="c1"># never found value below 1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="o">.</span><span class="n">full</span><span class="p">():</span>
                <span class="c1"># calibration extends to a data-not-available issue</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
                <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;do_recalibrate_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># no value below 1 was found within entire buffer,</span>
                <span class="c1"># assume that this was a false positive and discard</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;FAIL 3: envelope ratio never goes below 1&#39;</span><span class="p">)</span>
                    <span class="n">_chelper</span><span class="o">.</span><span class="n">do_plot</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>

        <span class="n">issue_start_time</span> <span class="o">=</span> <span class="n">issue_end_time</span> <span class="o">-</span> <span class="n">start_idx</span> <span class="o">/</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span>

        <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;initial_cal_start_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">issue_start_time</span>

        <span class="c1"># prepare to collect envelope stats</span>
        <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="n">search_start_idx</span><span class="p">::]</span>

    <span class="c1"># delete any detections that failed the previous step</span>
    <span class="n">clear_failed_detections</span><span class="p">(</span><span class="n">cal_detections</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;recalibrate issue start times&quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">cur_detection</span> <span class="ow">in</span> <span class="n">cal_detections</span><span class="p">:</span>
        <span class="n">issue_start_time</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;initial_cal_start_time&#39;</span><span class="p">]</span>
        <span class="n">issue_end_time</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;end_time&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;do_recalibrate_start&#39;</span> <span class="ow">in</span> <span class="n">cur_detection</span><span class="p">:</span>
            <span class="c1"># issue extends to a data-not-available issue,</span>
            <span class="c1"># skip recalibration</span>
            <span class="k">del</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;do_recalibrate_start&#39;</span><span class="p">]</span>
            <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">issue_start_time</span>
            <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;max_stalta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_pad</span> <span class="o">=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">recal_tShort</span> <span class="o">+</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">recal_tLong</span>

            <span class="c1"># get snippet of data from a bit before the calibration to the</span>
            <span class="c1"># end of the calibration</span>
            <span class="n">temp_starttime</span> <span class="o">=</span> <span class="n">issue_start_time</span> <span class="o">-</span> <span class="n">start_pad</span>
            <span class="n">temp_endtime</span> <span class="o">=</span> <span class="n">issue_end_time</span>

            <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">&lt;</span> <span class="n">temp_starttime</span><span class="p">:</span>
                <span class="n">start_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">temp_starttime</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span>
                                  <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>
                <span class="n">end_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">temp_endtime</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span>
                                <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>
                <span class="n">xtemp</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fc_starttime</span> <span class="o">&lt;</span> <span class="n">temp_starttime</span><span class="p">:</span>
                <span class="n">start_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">temp_starttime</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span>
                                  <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>
                <span class="n">end_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">temp_endtime</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span>
                                <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>

                <span class="n">xtemp</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span>
                <span class="n">xtemp_start_index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">x_curframe</span> <span class="ow">in</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="p">:</span>
                    <span class="n">xtemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x_curframe</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">))</span>
                    <span class="n">xtemp_start_index</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_curframe</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">xtemp_start_index</span> <span class="o">&lt;=</span> <span class="n">start_index</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="n">start_index</span> <span class="o">-=</span> <span class="n">xtemp_start_index</span>
                <span class="n">end_index</span> <span class="o">-=</span> <span class="n">xtemp_start_index</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">start_index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">start_index</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xtemp</span><span class="p">),</span> \
                    <span class="s1">&#39;not enough cached data&#39;</span>

                    <span class="n">xtemp</span> <span class="o">=</span> <span class="n">xtemp</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">xtemp</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xtemp</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">xtemp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># use the previously acquired snippent of time-series to</span>
                <span class="c1"># compute STA/LTA</span>
                <span class="n">xtemp</span> <span class="o">=</span> <span class="n">xtemp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>

                <span class="n">xtemp</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xtemp</span><span class="p">)</span>

                <span class="n">xtemp</span> <span class="o">=</span> <span class="n">pwc</span><span class="o">.</span><span class="n">sta_lta</span><span class="p">(</span><span class="n">xtemp</span><span class="p">,</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                                    <span class="n">t_short</span><span class="o">=</span><span class="n">_chelper</span><span class="o">.</span><span class="n">recal_tShort</span><span class="p">,</span>
                                    <span class="n">t_long</span><span class="o">=</span><span class="n">_chelper</span><span class="o">.</span><span class="n">recal_tLong</span><span class="p">)</span>

                <span class="n">adjustment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">xtemp</span><span class="p">)</span> <span class="o">/</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span> \
                             <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">recal_tShort</span>

                <span class="n">issue_start_time</span> <span class="o">=</span> <span class="n">issue_start_time</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">adjustment</span><span class="p">)</span>

                <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">issue_start_time</span>
                <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;max_stalta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xtemp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">issue_start_time</span>
                <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;max_stalta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># select steady-state subset of envelope</span>
        <span class="n">tempenv</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env&#39;</span><span class="p">]</span>
        <span class="n">tempenv</span> <span class="o">=</span> <span class="n">tempenv</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">int</span><span class="p">((</span><span class="n">issue_end_time</span> <span class="o">-</span> <span class="n">issue_start_time</span><span class="p">)</span>
                                <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span><span class="p">)]</span>
        <span class="n">tempenv</span> <span class="o">=</span> <span class="n">tempenv</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">tempenv</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                        <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">tempenv</span><span class="p">)])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># save envelope statistics</span>
        <span class="k">del</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tempenv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env_median&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tempenv</span><span class="p">)</span>
            <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env_median&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">tempenv</span><span class="p">)</span>
            <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">tempenv</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;store values to access in next frame&quot;&quot;&quot;</span>

    <span class="c1"># update time-series frame containers</span>
    <span class="k">if</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="n">_chelper</span><span class="o">.</span><span class="n">fc_starttime</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
    <span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">_chelper</span><span class="o">.</span><span class="n">FCy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">_chelper</span><span class="o">.</span><span class="n">FCsta</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sta</span><span class="p">)</span>
    <span class="n">_chelper</span><span class="o">.</span><span class="n">FClta</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lta</span><span class="p">)</span>
    <span class="n">_chelper</span><span class="o">.</span><span class="n">FCySmooth</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ySmooth</span><span class="p">)</span>
    <span class="n">_chelper</span><span class="o">.</span><span class="n">fc_endtime</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span>

    <span class="c1"># update &#39;zi&#39; frame container</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cal_detections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># only update this if no detection occurred</span>
        <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;absxLP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">zi</span> <span class="o">=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;absxLP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_chelper</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;absxLP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">zi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># clear the previous frames that included a calibration</span>
        <span class="c1"># (this assumes the duration for each trace is constant)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">cal_detections</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span>
        <span class="n">num_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">bufferdur</span><span class="p">)</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">num_frames</span><span class="p">,</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;plot results if debugging or running demo&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">do_plot</span> <span class="ow">or</span> <span class="n">__calibration_demo__</span><span class="p">:</span>
        <span class="c1"># add previous frames for plotting</span>
        <span class="c1"># num_extra_frames = 1</span>
        <span class="n">num_extra_frames</span> <span class="o">=</span> <span class="mi">120</span>
        <span class="n">num_extra_frames</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_extra_frames</span><span class="p">,</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">absx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_extra_frames</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">x</span><span class="p">))</span>
            <span class="n">absx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="n">absx</span><span class="p">))</span>
            <span class="n">sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCsta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">sta</span><span class="p">))</span>
            <span class="n">lta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FClta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">lta</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCy</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
            <span class="n">ySmooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCySmooth</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">ySmooth</span><span class="p">))</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">gridspec</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">gridspec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span>
        <span class="n">t</span> <span class="o">-=</span> <span class="n">num_extra_frames</span> <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">bufferdur</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=.</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data with DC removed&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCzi</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                 <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;typical envelope level for normalization (DC value)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">lta</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Long Term Average (LTA)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Short Term Average (STA)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;seismic data&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t (seconds)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cal_detections</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cur_detection</span> <span class="o">=</span> <span class="n">cal_detections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">issue_end_time</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;end_time&#39;</span><span class="p">]</span>

            <span class="c1"># plot envelope of last issue detection</span>
            <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>

            <span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="p">))</span> <span class="o">/</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span>
            <span class="n">t2</span> <span class="o">+=</span> <span class="n">issue_end_time</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span> <span class="n">t2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
                     <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">label</span><span class="o">=</span><span class="s1">&#39;envelope threshold (= 1)&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">env</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
                     <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                     <span class="n">label</span><span class="o">=</span><span class="s1">&#39;normalized envelope&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;envelope&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ax2</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span>
                          <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
                          <span class="n">ax2</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t (seconds)&#39;</span><span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=.</span><span class="mi">8</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;LTA / STA&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ySmooth</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;smoothed LTA / STA&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
                 <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;threshold trigger level&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;LTA/STA data&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># if len(issue_times) &gt; 0:</span>
        <span class="c1">#     plt.plot(t[0:len(env)], env[::-1], color=&#39;y&#39;)</span>

        <span class="k">for</span> <span class="n">cur_detection</span> <span class="ow">in</span> <span class="n">cal_detections</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;initial_cal_start_time&#39;</span><span class="p">]</span>
            <span class="n">te</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;initial_cal_end_time&#39;</span><span class="p">]</span>

            <span class="n">ps</span> <span class="o">=</span> <span class="n">pwc</span><span class="o">.</span><span class="n">get_plot_specs</span><span class="p">()</span>
            <span class="n">ps</span><span class="p">[</span><span class="s1">&#39;linestyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;--&#39;</span>
            <span class="n">ps</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">ps</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;g&#39;</span>
            <span class="n">issue_time</span> <span class="o">=</span> <span class="n">ts</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pwc</span><span class="o">.</span><span class="n">plot_vertical_line</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">issue_time</span><span class="p">,</span> <span class="n">ylims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pwc</span><span class="o">.</span><span class="n">plot_vertical_line</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">issue_time</span><span class="p">,</span> <span class="n">ylims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>

            <span class="n">ps</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
            <span class="n">issue_time</span> <span class="o">=</span> <span class="n">te</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pwc</span><span class="o">.</span><span class="n">plot_vertical_line</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">issue_time</span><span class="p">,</span> <span class="n">ylims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pwc</span><span class="o">.</span><span class="n">plot_vertical_line</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">issue_time</span><span class="p">,</span> <span class="n">ylims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>

            <span class="n">ts</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span>
            <span class="n">te</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;end_time&#39;</span><span class="p">]</span>

            <span class="n">ps</span> <span class="o">=</span> <span class="n">pwc</span><span class="o">.</span><span class="n">get_plot_specs</span><span class="p">()</span>
            <span class="n">ps</span><span class="p">[</span><span class="s1">&#39;linestyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="n">ps</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

            <span class="n">ps</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;g&#39;</span>
            <span class="n">issue_time</span> <span class="o">=</span> <span class="n">ts</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pwc</span><span class="o">.</span><span class="n">plot_vertical_line</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">issue_time</span><span class="p">,</span> <span class="n">ylims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pwc</span><span class="o">.</span><span class="n">plot_vertical_line</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">issue_time</span><span class="p">,</span> <span class="n">ylims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>

            <span class="n">ps</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
            <span class="n">issue_time</span> <span class="o">=</span> <span class="n">te</span> <span class="o">-</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pwc</span><span class="o">.</span><span class="n">plot_vertical_line</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">issue_time</span><span class="p">,</span> <span class="n">ylims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pwc</span><span class="o">.</span><span class="n">plot_vertical_line</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">issue_time</span><span class="p">,</span> <span class="n">ylims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="mf">1.1</span> <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">threshold</span><span class="p">)])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="sd">&quot;&quot;&quot;return final results&quot;&quot;&quot;</span>

    <span class="n">return_detections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cur_detection</span> <span class="ow">in</span> <span class="n">cal_detections</span><span class="p">:</span>
        <span class="n">issue_start_time</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span>
        <span class="n">issue_end_time</span> <span class="o">=</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;end_time&#39;</span><span class="p">]</span>
        <span class="n">snclq</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>

        <span class="sd">&quot;&quot;&quot;add additional statistics about the calibration&quot;&quot;&quot;</span>

        <span class="c1"># get the calibration segment of &#39;x&#39;</span>
        <span class="n">cal_x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="o">.</span><span class="n">size</span><span class="p">()):</span>
            <span class="n">cal_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">cal_x</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start_time</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_chelper</span><span class="o">.</span><span class="n">FCx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">/</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">issue_start_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">issue_end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>
        <span class="c1"># t = range(len(cal_x))</span>
        <span class="c1"># plt.plot(t, cal_x)</span>
        <span class="c1"># plt.plot(t[start_idx:end_idx], cal_x[start_idx:end_idx], color=&#39;r&#39;)</span>
        <span class="c1"># plt.show()</span>
        <span class="n">cal_x</span> <span class="o">=</span> <span class="n">cal_x</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>

        <span class="c1"># compute the STFT of the calibration</span>
        <span class="n">window_length</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># seconds</span>
        <span class="n">frame_size</span> <span class="o">=</span> <span class="n">window_length</span> <span class="o">*</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">f_stft</span> <span class="o">=</span> <span class="n">pwc</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">cal_x</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">_chelper</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">frame_size</span><span class="o">=</span><span class="n">frame_size</span><span class="p">)</span>
        <span class="c1"># get magnitudes of a subband</span>
        <span class="n">flo</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span>
        <span class="n">fhi</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="n">fidxlo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">f_stft</span> <span class="o">&gt;</span> <span class="n">flo</span><span class="p">])</span>
        <span class="n">fidxhi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">f_stft</span> <span class="o">&gt;</span> <span class="n">fhi</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">fidxhi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fidxhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_stft</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">fidxlo</span><span class="p">:</span><span class="n">fidxhi</span><span class="p">])</span>
        <span class="c1"># normalize</span>
        <span class="n">X</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cal_x</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>
        <span class="c1"># get the variance of the STFT per frequency bin</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">stft_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot;store results to detection&quot;&quot;&quot;</span>

        <span class="n">rd</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1"># start time (epoch time) of the identified calibration</span>
            <span class="s1">&#39;cal_start_time&#39;</span><span class="p">:</span> <span class="n">issue_start_time</span><span class="p">,</span>
            <span class="c1"># end time of the calibration</span>
            <span class="s1">&#39;cal_end_time&#39;</span><span class="p">:</span> <span class="n">issue_end_time</span><span class="p">,</span>

            <span class="c1"># initial detected start time before refining step</span>
            <span class="s1">&#39;initial_cal_start_time&#39;</span><span class="p">:</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;initial_cal_start_time&#39;</span><span class="p">],</span>
            <span class="c1"># initial detected end time before refining step</span>
            <span class="s1">&#39;initial_cal_end_time&#39;</span><span class="p">:</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;initial_cal_end_time&#39;</span><span class="p">],</span>

            <span class="c1"># maximum peak of initial detection trigger,</span>
            <span class="c1"># (larger implies more dramatic drop in energy)</span>
            <span class="s1">&#39;max_ySmooth&#39;</span><span class="p">:</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;max_ySmooth&#39;</span><span class="p">],</span>
            <span class="c1"># maximum STA/LTA at start of calibration, similar to</span>
            <span class="c1"># max_ySmooth but for start, not end</span>
            <span class="s1">&#39;max_stalta&#39;</span><span class="p">:</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;max_stalta&#39;</span><span class="p">],</span>
            <span class="c1"># average &quot;energy&quot; of the calibration</span>
            <span class="c1"># calibrations are likely to have a high env_mean</span>
            <span class="s1">&#39;env_mean&#39;</span><span class="p">:</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env_mean&#39;</span><span class="p">],</span>
            <span class="c1"># median &quot;energy&quot; of the calibration</span>
            <span class="c1"># calibrations are likely to have a high env_median</span>
            <span class="s1">&#39;env_median&#39;</span><span class="p">:</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env_median&#39;</span><span class="p">],</span>
            <span class="c1"># variance of the envelope</span>
            <span class="c1"># calibrations could have very high env_var but it&#39;s hard to say</span>
            <span class="s1">&#39;env_var&#39;</span><span class="p">:</span> <span class="n">cur_detection</span><span class="p">[</span><span class="s1">&#39;env_var&#39;</span><span class="p">],</span>
            <span class="c1"># mean variance of the STFT magnitude, if this is very high or</span>
            <span class="c1"># very low it is an indication of a calibration</span>
            <span class="s1">&#39;stft_var&#39;</span><span class="p">:</span> <span class="n">stft_var</span>
        <span class="p">}</span>
        <span class="n">return_detections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">return_detections</span></div>


<div class="viewcode-block" id="calibration"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.calibration">[docs]</a><span class="k">def</span> <span class="nf">calibration</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">metric_store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Refer to unscreened_calibration() for most details on this function.</span>
<span class="sd">    This function wraps unscreened_calibration and discards false alarms.</span>
<span class="sd">    At the moment it uses pre-trained machine learning objects however this</span>
<span class="sd">    can be implemented in different ways in the future.  The keys in a</span>
<span class="sd">    detection that are likely of interest to a user include:</span>
<span class="sd">      &#39;snclq&#39;, &#39;start_time&#39; and &#39;end_time&#39;</span>
<span class="sd">    Beyond that, these entries are strictly for screening false alarms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">detections</span> <span class="o">=</span> <span class="n">unscreened_calibration</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">metric_store</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">detections</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_chelper</span><span class="o">.</span><span class="n">iscal</span><span class="p">(</span><span class="n">detection</span><span class="o">=</span><span class="n">detections</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="k">del</span> <span class="n">detections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># Remove detections that are triggering on beginning of trace</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">detections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;cal_start_time&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">detections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">continue</span>
    <span class="c1"># Remove identical detections -- TODO this should really be fixed in the threshold triggering</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">detections</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">iden_detections</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;cal_start_time&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">]</span>
        <span class="n">dups</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iden_detections</span><span class="p">)</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iden_detections</span><span class="p">[:</span><span class="n">idx</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dups</span><span class="p">)):</span>
            <span class="n">detections</span><span class="p">[</span><span class="n">dups</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">detections</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">detections</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;nan&#39;</span><span class="p">]</span>

    <span class="c1"># converting time to isoformat</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">detections</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">detections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>

    <span class="c1"># If no detections are returned, create the following list dictionary</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;snclq&#39;</span><span class="p">:</span> <span class="n">trace</span><span class="o">.</span><span class="n">get_id</span><span class="p">(),</span> <span class="s1">&#39;start_time&#39;</span><span class="p">:</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span>
           <span class="s1">&#39;end_time&#39;</span><span class="p">:</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span> <span class="s1">&#39;num_cals_detected&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">detections</span><span class="p">),</span>
           <span class="s2">&quot;metric_name&quot;</span><span class="p">:</span> <span class="s2">&quot;calibrationMetric&quot;</span><span class="p">,</span> <span class="s2">&quot;detections&quot;</span><span class="p">:</span> <span class="n">detections</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="calibrationMetric"><a class="viewcode-back" href="../../../pycheron.metrics.calibration.html#pycheron.metrics.calibration.calibrationMetric">[docs]</a><span class="k">def</span> <span class="nf">calibrationMetric</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">metric_store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">database</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for calibration. Enable stream processing</span>
<span class="sd">    :param st: Stream object</span>

<span class="sd">    :return: List of calibration detections</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)):</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">calibration</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">metric_store</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">database</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">Database</span><span class="p">):</span>
        <span class="n">database</span><span class="o">.</span><span class="n">insert_metric</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="kn">import</span> <span class="nn">os</span>


    <span class="k">def</span> <span class="nf">print_results</span><span class="p">(</span><span class="n">detections</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">detection</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;snclq            : </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">detection</span><span class="p">[</span><span class="s1">&#39;snclq&#39;</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;issue_start_time : </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">detection</span><span class="p">[</span><span class="s1">&#39;cal_start_time&#39;</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;issue_end_time   : </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">detection</span><span class="p">[</span><span class="s1">&#39;cal_end_time&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;initial_cal_start_time&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;cal_start_time&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;cal_end_time&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;initial_cal_end_time&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;max_ySmooth&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;max_stalta&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;env_mean&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;env_median&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;env_var&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;stft_var&#39;</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%20s</span><span class="s1">  :  </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">detection</span><span class="p">[</span><span class="n">key</span><span class="p">])))</span>


    <span class="n">__calibration_demo__</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># test single trace</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;/test/test_data/7a_cabn_bhe.884965.tar.mseed&#39;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="n">calibration</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">detections</span><span class="p">)</span>
    <span class="c1"># print_results(detections)</span>

    <span class="c1"># &quot;&quot;&quot;PyWavCorr Config&quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># # This is the configuration for the Mongolia array stations</span>
    <span class="c1"># pwc.Station.set_class(pwc.ConfigFileStation)</span>
    <span class="c1"># pwc.Station.set_config({&#39;data_table&#39;: &#39;gnem_idcidcx.site_llnl&#39;,</span>
    <span class="c1">#                         &#39;filepath&#39;: os.path.dirname(pwc.__file__) \</span>
    <span class="c1">#                                     + &#39;/data/example_library.properties&#39;})</span>
    <span class="c1"># pwc.Waveform.set_class(pwc.WfdiscWaveform)</span>
    <span class="c1"># pwc.Waveform.set_config({&#39;data_table&#39;: &#39;gnem_idcidcx.wfdisc_snl&#39;,</span>
    <span class="c1">#                          &#39;wfdisc_path&#39;: &#39;/mnt/wf_data/&#39;})</span>
    <span class="c1">#</span>
    <span class="c1"># # test streaming traces</span>
    <span class="c1"># num_loops = 4</span>
    <span class="c1"># duration = 60 * 5</span>
    <span class="c1"># station = pwc.Station(&#39;MKAR&#39;)</span>
    <span class="c1"># sensor = pwc.Sensor(&#39;MKAR&#39;, &#39;MK01&#39;, &#39;SHZ&#39;)</span>
    <span class="c1"># start_time = obspy.UTCDateTime(2013, 7, 4, 15, 50, 30).timestamp</span>
    <span class="c1"># end_time = start_time + duration</span>
    <span class="c1">#</span>
    <span class="c1"># for i in range(num_loops):</span>
    <span class="c1">#     waveform = pwc.SafeWaveform(station, sensor, start_time, end_time)</span>
    <span class="c1">#     tr = pwc.waveform2trace(waveform)</span>
    <span class="c1">#     # tr.plot()</span>
    <span class="c1">#     detections = calibration(tr)</span>
    <span class="c1">#     # print_results(detections)</span>
    <span class="c1">#</span>
    <span class="c1">#     start_time = end_time</span>
    <span class="c1">#     end_time += duration</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2019, Jessica Bobeck, Katherine Anderson Aur.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.9.<br/>
    </p>
  </div>
</footer>
  </body>
</html>