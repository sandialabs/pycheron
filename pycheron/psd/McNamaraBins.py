#####################################################################################
# Copyright 2019 National Technology & Engineering Solutions of Sandia, LLC (NTESS).
# Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains
# certain rights in this software.
#####################################################################################
# NOTICE:
# For five (5) years from 10/21/2019 the United States Government is granted for
# itself and others acting on its behalf a paid-up, nonexclusive, irrevocable worldwide
# license in this data to reproduce, prepare derivative works, and perform publicly and
# display publicly, by or on behalf of the Government. There is provision for the
# possible extension of the term of this license. Subsequent to that period or any
# extension granted, the United States Government is granted for itself and others
# acting on its behalf a paid-up, nonexclusive, irrevocable worldwide license in this
# data to reproduce, prepare derivative works, distribute copies to the public,
# perform publicly and display publicly, and to permit others to do so. The specific
# term of the license can be identified by inquiry made to National Technology and
# Engineering Solutions of Sandia, LLC or DOE. NEITHER THE UNITED STATES GOVERNMENT,
# NOR THE UNITED STATES DEPARTMENT OF ENERGY, NOR NATIONAL TECHNOLOGY AND ENGINEERING
# SOLUTIONS OF SANDIA, LLC, NOR ANY OF THEIR EMPLOYEES, MAKES ANY WARRANTY, EXPRESS OR
# IMPLIED, OR ASSUMES ANY LEGAL RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
# USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS DISCLOSED, OR REPRESENTS
# THAT ITS USE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS. Any licensee of this software
# has the obligation and responsibility to abide by the applicable export control laws,
# regulations, and general prohibitions relating to the export of technical data.
# Failure to obtain an export control license or other authority from the Government
# may result in criminal liability under U.S. laws.
# (End of Notice)
####################################################################################

__all__ = ["McNamaraBins"]

import numpy as np
from math import log


def McNamaraBins(f, spec, loFreq=0.005, hiFreq=10, alignFreq=0.1):
    """
    Calculate average values in bins using the McNamara algorithm [#]_.

    Frequencies for binning will be generated at 1/8 octave intervals aligned to alignFreq. Frequency smooth the
    averaged spectral values over 1-octave intervals at 1/8-octave increments, (reducing # frequency samples by factor
    of 169; include 10 Hz as one of the geometric mean f values to sync f sampling). In other words, binned values
    associated with each frequency bin are calculated by averaging incoming values over an entire octave centered on
    that frequency. The frequency smoothing (second to last step) involves averaging power values over an octave using
    a geometric mean and repeating at 1/8 octave intervals in frequency.

    :param f: Array of frequency values
    :type f: numpy.ndarray
    :param spec: Array of spectral values generated by a PSD/CrossSpectrum function
    :type spec: numpy.ndarray
    :param loFreq: Low end of frequency binning range
    :type loFreq: int
    :param hiFreq: High end of frequency binning range
    :type hiFreq: int
    :param alignFreq: Alignment frequency for determining frequency bins
    :type alignFreq: int

    :return: Returns 2 arrays:

        * Binned frequency array (`numpy.ndarray`)
        * Binned Spectral array (`numpy.ndarray`)

    .. rubric:: References

    .. [#] http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf




    """

    # Define "center" frequencies at 1/8 octave intervals
    if alignFreq >= hiFreq:
        octs = np.arange(log(alignFreq, 2), log(loFreq, 2), -0.125)
        octaves = octs[octs <= log(hiFreq, 2)]
    elif alignFreq <= loFreq:
        octs = np.arange(log(alignFreq, 2), log(hiFreq, 2), 0.125)
        octaves = octs[octs >= log(loFreq, 2)]
    else:
        loOctaves = np.arange(log(alignFreq, 2), log(loFreq, 2), -0.125)
        hiOctaves = np.arange(log(alignFreq, 2), log(hiFreq, 2), 0.125)
        octaves = np.sort(np.unique(np.append(loOctaves, hiOctaves)))

    # Define bins starting at zero so that freq #1 has bin 0 to the left and bin 1 to the right. Calculate
    # halfOctaveabove to use for binning
    binFreq = np.sort(2 ** octaves)
    halfOctaveAbove = 2 ** (log(hiFreq, 2) + 0.5)
    binFreq1 = np.append(binFreq, np.array([halfOctaveAbove]))

    # To ensure binFreq1 aligns with frequency insert a zero at the beginning
    # binFreq1 = np.insert(binFreq1, 0, 0)

    # binning-first bin begins at zero to ensure that the bin numbering aligns with the frequency numbering
    bins = np.digitize(f, binFreq1) - 1

    # Extract bins as appropriate, based on loFreq cutoff
    index = len(f[f <= loFreq])
    bins = bins[index:]
    spec = spec[index:]

    # initializing containers for return values
    dfp = np.zeros((len(binFreq)))
    dff = binFreq

    # Loop through the bin numbers and calculate the geometric mean of all values in an octave (8 bins) centered on that
    # frequency. For example, freq #1 should average all frequencies in bins 0,1,2,3,4; freq #6 should have bins
    # 2,3,4,5,6,7,8,9.
    for i in range(len(binFreq)):
        loBin = max(0, i - 4)
        hiBin = min(i + 3, np.nanmax(bins))

        # Determine which values are in this octave
        idx_lo = np.argmax(bins >= loBin)
        idx_hi = np.argmax(bins > hiBin)

        if idx_lo == idx_hi:
            continue
        elif idx_hi == 0 and idx_hi != idx_lo:
            idx_hi = len(bins)

        # Calculate mean of bin, then return binned frequency and spectral arrays
        dfp[i] = np.mean(spec[idx_lo:idx_hi])

    # Trim zeros from the front end of the spectral array in the case that the user didn't choose an appropriate z
    # and loFreq cutoff -- if this is happening though, the dff and dfp arrays not be the same length, and a few lines
    # should be added to cut the dff array in the same manner based off of how many zeros are removed.
    dfp = np.trim_zeros(dfp)

    return dff, dfp
