#####################################################################################
# Copyright 2019 National Technology & Engineering Solutions of Sandia, LLC (NTESS).
# Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains
# certain rights in this software.
#####################################################################################
# NOTICE:
# For five (5) years from 10/21/2019 the United States Government is granted for
# itself and others acting on its behalf a paid-up, nonexclusive, irrevocable worldwide
# license in this data to reproduce, prepare derivative works, and perform publicly and
# display publicly, by or on behalf of the Government. There is provision for the
# possible extension of the term of this license. Subsequent to that period or any
# extension granted, the United States Government is granted for itself and others
# acting on its behalf a paid-up, nonexclusive, irrevocable worldwide license in this
# data to reproduce, prepare derivative works, distribute copies to the public,
# perform publicly and display publicly, and to permit others to do so. The specific
# term of the license can be identified by inquiry made to National Technology and
# Engineering Solutions of Sandia, LLC or DOE. NEITHER THE UNITED STATES GOVERNMENT,
# NOR THE UNITED STATES DEPARTMENT OF ENERGY, NOR NATIONAL TECHNOLOGY AND ENGINEERING
# SOLUTIONS OF SANDIA, LLC, NOR ANY OF THEIR EMPLOYEES, MAKES ANY WARRANTY, EXPRESS OR
# IMPLIED, OR ASSUMES ANY LEGAL RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
# USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS DISCLOSED, OR REPRESENTS
# THAT ITS USE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS. Any licensee of this software
# has the obligation and responsibility to abide by the applicable export control laws,
# regulations, and general prohibitions relating to the export of technical data.
# Failure to obtain an export control license or other authority from the Government
# may result in criminal liability under U.S. laws.
# (End of Notice)
####################################################################################

__all__ = ["basicStatsMetric"]

import numpy as np
from pycheron.util.masks import samples2time
from pycheron.util.logger import Logger
from pycheron.db.sqllite_db import Database


def basicStatsMetric(
    st,
    rmsThreshold=50000,
    peggedThreshold=10e7,
    maxThreshold=None,
    minThreshold=None,
    medianThreshold=None,
    meanThreshold=None,
    varianceThreshold=None,
    stdThreshold=None,
    generateMasks=False,
    masksByTime=True,
    logger=None,
    database_config=None,
):
    """
    Reads in Stream object, creates Trace data, and outputs basic statistics for each respective trace
    (Trace ID, Number of Samples, Start Time, End Time, Minimum, Maximum, Median, Mean, Variance, Standard Deviation,
    RMS, Masks)

    :param st: obspy stream object
    :type st: obspy.core.stream.Stream
    :param rmsTheshold: RMS threshold, if value above theshold then values are masked.
    :type rmsThreshold: int
    :param peggedThreshold: If abs(sample_mean) > 10e+7 (default) then likely indicates a pegged mass.
                            If value above threshold then values are masked
    :type peggedThreshold: float
    :param maxThreshold: Max value threshold, if value above theshold then values are masked.
    :type maxThreshold: int
    :param minThreshold: Min value threshold, if value above theshold then values are masked.
    :type minThreshold: int
    :param medianThreshold:  Median value threshold, if value above theshold then values are masked.
    :type medianThreshold: int
    :param meanThreshold: Mean value threshold, if value above theshold then values are masked.
    :type meanThreshold: int
    :param varianceThreshold: Variance threshold, if value above theshold then values are masked.
    :type varianceThreshold: int
    :param stdThreshold:  Standard deviation threshold, if value above theshold then values are masked.
    :type stdThreshold: int
    :param generateMasks: Return generated masks.
    :type generateMasks: bool
    :param masksByTime: Boolean to determine whether masks are generated by time. If True, masks will be generated with
                        a start/end time, if false, they will be generated as boolean array.
    :type masksByTime: bool
    :param logger: If using a logger, (you must create one using the util.logger class)
    :type logger: pycheron.util.logger.Logger
    :param database_config: dictionary containing the necessary parameters to create
                            a pycheron Database object. 
                            These include "db_name", "session_name", "overwrite", "manual", "wfdb_conn"
    :type database_config: dict

    :return: a dictionary with the following keys and types:

                * snclq (`str`)
                * number_of_samples (`int`)
                * start_time (`str`)
                * end_time (`str`)
                * minimum (`float`)
                * maximum (`float`)
                * median (`float`)
                * mean (`float`)
                * variance (`float`)
                * standard_deviation (`float`)
                * rms (`float`)
                * metric_name (`str`)
                * minThreshExceeded (`bool`) boolean value indicating whether minstats exceeded minThreshold
                * maxThreshExceeded (`bool`) boolean value indicating whether maxstats exceeded maxThreshold
                * medianThreshExceeded (`bool`) boolean value indicating whether medianstats exceeded medianThreshold
                * meanThreshExceeded (`bool`) boolean value indicating whether meanstats exceeded meanThreshold
                * varianceThreshExceeded (`bool`) boolean value indicating whether variancestats exceeded
                                                  varianceThreshold
                * stdThreshExceeded (`bool`) boolean value indicating whether stdstats exceeded stdThreshold
                * highAmp (`bool`) boolean value indicating whether rmsstats exceeded rmsThreshold
                * pegged (`bool`) boolean value indicating whether abs(meanstats) exceeded peggedThreshold
                * min_mask (`list` or `numpy.ndarray`)
                * max_mask (`list` or `numpy.ndarray`)
                * median_mask (`list` or `numpy.ndarray`)
                * mean_mask (`list` or `numpy.ndarray`)
                * variance_mask (`list` or `numpy.ndarray`)
                * std_mask (`list` or `numpy.ndarray`)
                * highAmp_rms_mask (`list` or `numpy.ndarray`)
                * pegged_mask (`list` or `numpy.ndarray`)

    :rtype: dict

    * Code originally ported from IRISMustangMetrics R Cran Package
    (Callahan, J., R. Casey, M. Templeton, and G. Sharer (2020, March 20). CRAN-Package IRISMustangMetrics.
    The Comprehensive R Archive Network. Retrieved from
    https://cran.r-project.org/web/packages/IRISMustangMetrics/index.html) and augmented and adapted for use within
    Pycheron

    **Examples**

    .. code-block:: python

        #test data
        data = 'test/test_data/7a_cabn_bhe.884965.tar.mseed'
        #reading in stream
        st = obspy.read(data)
        #Calculate stats
        stats = basicStatsMetric(st)
        print stats
        >>> [{'rms': 1426.1056439005754, 'number_of_samples': 3456410, 'metric_name': 'basicStatsMetric',
              'max_mask': None, 'std_mask': None, 'standard_deviation': 1412.9280231274283,
              'start_time': UTCDateTime(2013, 11, 1, 0, 0), 'median': 27.0, 'maximum': 10336,
              'snclq': u'7A.CABN..BHE', 'min_mask': None, 'variance_mask': None, 'minimum': -6870,
              'end_time': UTCDateTime(2013, 11, 2, 0, 0, 10, 225000), 'median_mask': None,
              'variance': 1996365.598538783, 'mean_mask': None, 'rms_mask': None, 'mean': 193.42106665586547}]

    If `generateMasks=True`, masks will be generated for those values that have thresholds.

    .. code-block:: python

        #Calculate stats with masks
        stats = basicStatsMetric(st, generateMasks=True)
        print stats
        >>> [{'rms': 1426.1056439005754, 'number_of_samples': 3456410, 'metric_name': 'basicStatsMetric',
              'max_mask': 'No masks were created: Either threshold was set to None or value was below threshold',
              'std_mask': 'No masks were created: Either threshold was set to None or value was below threshold',
              'standard_deviation': 1412.9280231274283, 'start_time': UTCDateTime(2013, 11, 1, 0, 0),
              'median': 27.0, 'maximum': 10336, 'snclq': u'7A.CABN..BHE',
              'min_mask': 'No masks were created: Either threshold was set to None or value was below threshold',
              'variance_mask': 'No masks were created: Either threshold was set to None or value was below threshold',
              'minimum': -6870, 'end_time': UTCDateTime(2013, 11, 2, 0, 0, 10, 225000),
              'median_mask': 'No masks were created: Either threshold was set to None or value was below threshold',
              'variance': 1996365.598538783,
              'mean_mask': 'No masks were created: Either threshold was set to None or value was below threshold',
              'rms_mask': 'No masks were created: Either threshold was set to None or value was below threshold',
              'mean': 193.42106665586547}]
    """

    # Set up logger
    if logger is None:
        logger = Logger(None)

    # Initialize d to make list of dictionaries
    d = []

    # Loop through stream object and get starttime, endtime, snclq, and length for each trace then calculate stats.
    # Store in list of dictionaries.
    for i in range(len(st)):
        trace = st[i]
        fs = trace.stats["sampling_rate"]
        starttime = trace.stats.starttime
        endtime = trace.stats.endtime
        snclq = trace.get_id()
        length = len(trace)

        # Access trace data in NumPy array format
        data = trace.data

        # Calculate Statistics from Array
        # Minimum, Maximum, Median, Mean, Variance, Standard Deviation, RMS
        minstats = np.amin(data)
        maxstats = np.amax(data)
        medianstats = np.median(data)
        meanstats = np.mean(data)
        variancestats = np.var(data)
        stdstats = np.std(data)
        rmsstats = np.sqrt(abs(np.mean(data ** 2)))

        # initializing masks
        minMask = None
        maxMask = None
        medMask = None
        meanMask = None
        varMask = None
        stdMask = None
        rmsMask = None
        peggedMask = None

        # Boolean checks to see if exceeded user defined thresholds for the various statistics
        # min
        try:
            if minstats > minThreshold:
                minThreshExceeded = 1
            else:
                minThreshExceeded = 0
        except TypeError:
            minThreshExceeded = 0
        # max
        try:
            if maxstats > maxThreshold:
                maxThreshExceeded = 1
            else:
                maxThreshExceeded = 0
        except TypeError:
            maxThreshExceeded = 0
        # median
        try:
            if medianstats > medianThreshold:
                medianThreshExceeded = 1
            else:
                medianThreshExceeded = 0
        except TypeError:
            medianThreshExceeded = 0
        # mean
        try:
            if meanstats > meanThreshold:
                meanThreshExceeded = 1
            else:
                meanThreshExceeded = 0
        except TypeError:
            meanThreshExceeded = 0
        # variance
        try:
            if variancestats > varianceThreshold:
                varianceThreshExceeded = 1
            else:
                varianceThreshExceeded = 0
        except TypeError:
            varianceThreshExceeded = 0
        # std
        try:
            if stdstats > stdThreshold:
                stdThreshExceeded = 1
            else:
                stdThreshExceeded = 0
        except TypeError:
            stdThreshExceeded = 0
        # rms
        try:
            if rmsstats > rmsThreshold:
                highAmp = 1
            else:
                highAmp = 0
        except TypeError:
            highAmp = 0
        # pegged
        try:
            if abs(meanstats) > peggedThreshold:
                pegged = 1
            else:
                pegged = 0
        except TypeError:
            pegged = 0

        # creating masks
        if generateMasks:
            # Min masks
            minMask = _makeMask(
                data,
                minThreshold,
                minstats,
                fs,
                starttime,
                greaterThan=False,
                time=masksByTime,
            )
            # Max masks
            maxMask = _makeMask(data, maxThreshold, maxstats, fs, starttime, time=masksByTime)
            # Median masks
            medMask = _makeMask(data, medianThreshold, medianstats, fs, starttime, time=masksByTime)
            # Mean masks
            meanMask = _makeMask(data, meanThreshold, meanstats, fs, starttime, time=masksByTime)
            # Variance masks
            varMask = _makeMask(data, varianceThreshold, variancestats, fs, starttime, time=masksByTime)
            # Standard Deviation masks
            stdMask = _makeMask(data, stdThreshold, stdstats, fs, starttime, time=masksByTime)
            # RMS masks
            rmsMask = _makeMask(data, rmsThreshold, rmsstats, fs, starttime, time=masksByTime)
            # Pegged masks
            peggedMask = _makeMask(data, peggedThreshold, abs(meanstats), fs, starttime, time=masksByTime)

        # Create index of keys for the output dictionary
        index = [
            "snclq",
            "number_of_samples",
            "start_time",
            "end_time",
            "minimum",
            "maximum",
            "median",
            "mean",
            "variance",
            "standard_deviation",
            "rms",
            "metric_name",
        ]

        # Append to output dictionary
        d.append(
            {
                index[0]: snclq,
                index[1]: length,
                index[2]: starttime,
                index[3]: endtime,
                index[4]: minstats,
                index[5]: maxstats,
                index[6]: medianstats,
                index[7]: meanstats,
                index[8]: variancestats,
                index[9]: stdstats,
                index[10]: rmsstats,
                index[11]: "basicStatsMetric",
                "min_threshold_exceeded": minThreshExceeded,
                "max_threshold_exceeded": maxThreshExceeded,
                "median_threshold_exceeded": medianThreshExceeded,
                "mean_threshold_exceeded": meanThreshExceeded,
                "variance_threshold_exceeded": varianceThreshExceeded,
                "std_threshold_exceeded": stdThreshExceeded,
                "highAmp": highAmp,
                "pegged": pegged,
                "min_mask": minMask,
                "max_mask": maxMask,
                "median_mask": medMask,
                "mean_mask": meanMask,
                "variance_mask": varMask,
                "std_mask": stdMask,
                "highAmp_rms_mask": rmsMask,
                "pegged_mask": peggedMask,
            }
        )

    # Put information in the database if defined
    if database_config is not None:
        database = Database(**database_config)
        database.insert_metric(d)

    return d


def _makeMask(data, threshold, stat, fs, starttime, greaterThan=True, time=True):
    """
    Makes QC Mask
    :param data: (arr) trace data
    :param threshold: (int) threshold value
    :param stat: (int) value to be compared to threshold
    :param greaterThan: (bool) If value should be greater than theshold. Default = True. If false, value shoudl be less
    than theshold
    :return: (arr) Boolean array of 0 and 1s, 0 is False. 1 is True.
    """
    mask = None
    if time:
        if greaterThan:
            if threshold is not None and stat > threshold:
                index = np.where(data > threshold)[0]
                mask = samples2time(index, fs, starttime)
            return mask

        else:
            if threshold is not None and stat < threshold:
                index = np.where(data < threshold)[0]
                mask = samples2time(index, fs, starttime)
            return mask
    elif not time:
        if greaterThan:
            if threshold is not None and stat > threshold:
                index = np.where(data > threshold)
                mask = np.zeros(len(data), dtype=int)
                mask[index] = 1
            return mask

        else:
            if threshold is not None and stat < threshold:
                index = np.where(data < threshold)
                mask = np.zeros(len(data), dtype=int)
                mask[index] = 1
            return mask
    else:
        return mask
