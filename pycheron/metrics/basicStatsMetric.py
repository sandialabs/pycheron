#####################################################################################
# Copyright 2019 National Technology & Engineering Solutions of Sandia, LLC (NTESS).
# Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains
# certain rights in this software.
#####################################################################################
# NOTICE:
# For five (5) years from 10/21/2019 the United States Government is granted for
# itself and others acting on its behalf a paid-up, nonexclusive, irrevocable worldwide
# license in this data to reproduce, prepare derivative works, and perform publicly and
# display publicly, by or on behalf of the Government. There is provision for the
# possible extension of the term of this license. Subsequent to that period or any
# extension granted, the United States Government is granted for itself and others
# acting on its behalf a paid-up, nonexclusive, irrevocable worldwide license in this
# data to reproduce, prepare derivative works, distribute copies to the public,
# perform publicly and display publicly, and to permit others to do so. The specific
# term of the license can be identified by inquiry made to National Technology and
# Engineering Solutions of Sandia, LLC or DOE. NEITHER THE UNITED STATES GOVERNMENT,
# NOR THE UNITED STATES DEPARTMENT OF ENERGY, NOR NATIONAL TECHNOLOGY AND ENGINEERING
# SOLUTIONS OF SANDIA, LLC, NOR ANY OF THEIR EMPLOYEES, MAKES ANY WARRANTY, EXPRESS OR
# IMPLIED, OR ASSUMES ANY LEGAL RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
# USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS DISCLOSED, OR REPRESENTS
# THAT ITS USE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS. Any licensee of this software
# has the obligation and responsibility to abide by the applicable export control laws,
# regulations, and general prohibitions relating to the export of technical data.
# Failure to obtain an export control license or other authority from the Government
# may result in criminal liability under U.S. laws.
# (End of Notice)
####################################################################################

__all__ = ["basicStatsMetric"]

import numpy as np
from pycheron.util.masks import samples2time


def basicStatsMetric(
    st,
    rmsThreshold=50000,
    maxThreshold=None,
    minThreshold=None,
    medianThreshold=None,
    meanThreshold=None,
    varianceThreshold=None,
    stdThreshold=None,
    generateMasks=False,
    masksByTime=True,
    logger=None,
    database=None,
):
    """
    Reads in stream object and creates Trace data, and outputs basic statistic (Trace ID, Number of Samples, Start Time, End Time, Minimum, Maximum, Median, Mean, Variance, Standard Deviation, Masks)

    :param st: obspy stream object
    :type st: obspy.core.stream.Stream
    :param rmsTheshold: RMS threshold, if value above theshold then values are masked.
    :type rmsThreshold: int
    :param maxThreshold: Max value threshold, if value above theshold then values are masked.
    :type maxThreshold: int
    :param minThreshold: Min value threshold, if value above theshold then values are masked.
    :type minThreshold: int
    :param medianThreshold:  Median value threshold, if value above theshold then values are masked.
    :type medianThreshold: int
    :param meanThreshold: Mean value threshold, if value above theshold then values are masked.
    :type meanThreshold: int
    :param varianceThreshold: Variance threshold, if value above theshold then values are masked.
    :type varianceThreshold: int
    :param stdThreshold:  Standard deviation threshold, if value above theshold then values are masked.
    :type stdThreshold: int
    :param generateMasks: Return generated masks.
    :type generateMasks: bool
    :param masksByTime: Boolean to determine whether masks are generated by time. If True, masks will be generated with a start/end time, if false, they will be generated as boolean array.
    :type masksByTime: bool
    :param logger: If using a logger, (you must create one using the util.logger class)
    :type logger: pycheron.util.logger.Logger
    :param database: database object
    :type database: pycheron.db.sqllite_db.Database

    :return: a dictionary with the following keys and types:

                * snclq (`str`)
                * number_of_samples (`int`)
                * start_time (`str`)
                * end_time (`str`)
                * minimum (`float`)
                * maximum (`float`)
                * median (`float`)
                * mean (`float`)
                * variance (`float`)
                * standard_deviation (`float`)
                * rms (`float`)
                * metric_name (`str`)
                * min_mask (`list` or `numpy.ndarray`)
                * max_mask (`list` or `numpy.ndarray`)
                * median_mask (`list` or `numpy.ndarray`)
                * mean_mask (`list` or `numpy.ndarray`)
                * variance_mask (`list` or `numpy.ndarray`)
                * std_mask (`list` or `numpy.ndarray`)
                * rms_mask (`list` or `numpy.ndarray`)

    :rtype: dict

    **Examples**

    .. code-block:: python

        #test data
        data = 'test/test_data/7a_cabn_bhe.884965.tar.mseed'
        #reading in stream
        st = obspy.read(data)
        #Calculate stats
        stats = basicStatsMetric(st)
        print stats
        >>> [{'rms': 1426.1056439005754, 'number_of_samples': 3456410, 'metric_name': 'basicStatsMetric', 'max_mask': None, 'std_mask': None, 'standard_deviation': 1412.9280231274283, 'start_time': UTCDateTime(2013, 11, 1, 0, 0), 'median': 27.0, 'maximum': 10336, 'snclq': u'7A.CABN..BHE', 'min_mask': None, 'variance_mask': None, 'minimum': -6870, 'end_time': UTCDateTime(2013, 11, 2, 0, 0, 10, 225000), 'median_mask': None, 'variance': 1996365.598538783, 'mean_mask': None, 'rms_mask': None, 'mean': 193.42106665586547}]

    If `generateMasks=True`, masks will be generated for those values that have thresholds.

    .. code-block:: python

        #Calculate stats with masks
        stats = basicStatsMetric(st, generateMasks=True)
        print stats
        >>> [{'rms': 1426.1056439005754, 'number_of_samples': 3456410, 'metric_name': 'basicStatsMetric', 'max_mask': 'No masks were created: Either threshold was set to None or value was below threshold', 'std_mask': 'No masks were created: Either threshold was set to None or value was below threshold', 'standard_deviation': 1412.9280231274283, 'start_time': UTCDateTime(2013, 11, 1, 0, 0), 'median': 27.0, 'maximum': 10336, 'snclq': u'7A.CABN..BHE', 'min_mask': 'No masks were created: Either threshold was set to None or value was below threshold', 'variance_mask': 'No masks were created: Either threshold was set to None or value was below threshold', 'minimum': -6870, 'end_time': UTCDateTime(2013, 11, 2, 0, 0, 10, 225000), 'median_mask': 'No masks were created: Either threshold was set to None or value was below threshold', 'variance': 1996365.598538783, 'mean_mask': 'No masks were created: Either threshold was set to None or value was below threshold', 'rms_mask': 'No masks were created: Either threshold was set to None or value was below threshold', 'mean': 193.42106665586547}]
    """

    # Initialize d to make list of dictionaries
    d = []

    # Loop through stream object and get starttime, endtime, snclq, and length for each trace then calculate stats.
    # Store in list of dictionaries.
    for i in range(len(st)):
        trace = st[i]
        fs = trace.stats["sampling_rate"]
        starttime = trace.stats.starttime
        endtime = trace.stats.endtime
        snclq = trace.get_id()
        length = len(trace)

        # Access trace data in NumPy array format
        data = trace.data

        # Calculates Stats from Array
        # Minimum, Maximum, Median, Mean, Variance, Standard Deviation
        minstats = np.amin(data)
        maxstats = np.amax(data)
        medianstats = np.median(data)
        meanstats = np.mean(data)
        variancestats = np.var(data)
        stdstats = np.std(data)
        rmsstats = np.sqrt(abs(np.mean(data ** 2)))

        # initializing masks
        minMask = None
        maxMask = None
        medMask = None
        meanMask = None
        varMask = None
        stdMask = None
        rmsMask = None

        # creating masks
        if generateMasks == True:
            # Minimum
            minMask = _makeMask(
                data,
                minThreshold,
                minstats,
                fs,
                starttime,
                greaterThan=False,
                time=masksByTime,
            )
            # Maximum
            maxMask = _makeMask(
                data, maxThreshold, maxstats, fs, starttime, time=masksByTime
            )
            # Median
            medMask = _makeMask(
                data, medianThreshold, medianstats, fs, starttime, time=masksByTime
            )
            # Mean
            meanMask = _makeMask(
                data, meanThreshold, meanstats, fs, starttime, time=masksByTime
            )
            # Variance
            varMask = _makeMask(
                data, varianceThreshold, variancestats, fs, starttime, time=masksByTime
            )
            # Standard Deviation
            stdMask = _makeMask(
                data, stdThreshold, stdstats, fs, starttime, time=masksByTime
            )
            # RMS
            rmsMask = _makeMask(
                data, rmsThreshold, rmsstats, fs, starttime, time=masksByTime
            )

        # Create index of keys
        index = [
            "snclq",
            "number_of_samples",
            "start_time",
            "end_time",
            "minimum",
            "maximum",
            "median",
            "mean",
            "variance",
            "standard_deviation",
            "rms",
            "metric_name",
        ]

        # Dictionary of data
        d.append(
            {
                index[0]: snclq,
                index[1]: length,
                index[2]: starttime,
                index[3]: endtime,
                index[4]: minstats,
                index[5]: maxstats,
                index[6]: medianstats,
                index[7]: meanstats,
                index[8]: variancestats,
                index[9]: stdstats,
                index[10]: rmsstats,
                index[11]: "basicStatsMetric",
                "min_mask": minMask,
                "max_mask": maxMask,
                "median_mask": medMask,
                "mean_mask": meanMask,
                "variance_mask": varMask,
                "std_mask": stdMask,
                "rms_mask": rmsMask,
            }
        )

    if database is not None:
        database.insert_metric(d)

    return d


def _makeMask(data, threshold, stat, fs, starttime, greaterThan=True, time=True):
    """
    Makes QC Mask
    :param data: (arr) trace data
    :param threshold: (int) threshold value
    :param stat: (int) value to be compared to threshold
    :param greaterThan: (bool) If value should be greater than theshold. Default = True. If false, value shoudl be less
    than theshold
    :return: (arr) Boolean array of 0 and 1s, 0 is False. 1 is True.
    """
    mask = None
    if time:
        if greaterThan:
            if threshold is not None and stat > threshold:
                index = np.where(data > threshold)[0]
                mask = samples2time(index, fs, starttime)
            return mask

        else:
            if threshold is not None and stat < threshold:
                index = np.where(data < threshold)[0]
                mask = samples2time(index, fs, starttime)
            return mask
    elif not time:
        if greaterThan:
            if threshold is not None and stat > threshold:
                index = np.where(data > threshold)
                mask = np.zeros(len(data), dtype=int)
                mask[index] = 1
            return mask

        else:
            if threshold is not None and stat < threshold:
                index = np.where(data < threshold)
                mask = np.zeros(len(data), dtype=int)
                mask[index] = 1
            return mask
    else:
        return mask
